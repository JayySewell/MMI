<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MMI ‚Äì Synthetic AI v2.0</title>
  <style>
    :root {
      --bg: #0d0d0f;
      --panel: #111;
      --ink: #eee;
      --line: #333;
      --blue: #4ac3ff;
      --purple: #a24aff;
      --green: #4affa2;
      --orange: #ffa24a;
      --red: #ff4a4a;
      --yellow: #ffd84a;
      --pink: #ff4ad8;
      --teal: #4affd8;
    }
    * { box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding: 20px;
      margin: 0;
    }
    h1 { 
      color: var(--blue); 
      margin-bottom: 15px;
      text-align: center;
      text-shadow: 0 0 10px rgba(74, 195, 255, 0.5);
    }
    h2 { 
      color: var(--purple); 
      margin-top: 0;
      border-bottom: 1px solid var(--purple);
      padding-bottom: 8px;
    }
    h3 { 
      color: var(--green); 
      margin-top: 0; 
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    h3::before {
      content: "‚ñ∂";
      font-size: 10px;
      color: var(--green);
    }
    #chat, #trainer, #dashboard, #advanced {
      background: var(--panel);
      border: 1px solid var(--blue);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
      transition: all 0.3s ease;
    }
    #chat:hover, #trainer:hover, #dashboard:hover, #advanced:hover {
      box-shadow: 0 0 20px rgba(74, 195, 255, 0.2);
    }
    #dashboard { border-color: var(--purple); }
    #advanced { border-color: var(--green); }
    #log {
      height: 240px;
      background: #1a1a1f;
      overflow-y: auto;
      padding: 12px;
      border: 1px solid var(--line);
      margin-bottom: 10px;
      white-space: pre-wrap;
      border-radius: 6px;
      font-size: 14px;
      line-height: 1.4;
    }
    #userInput, textarea, select {
      width: 100%;
      padding: 10px;
      background: #222;
      color: var(--ink);
      border: 1px solid var(--blue);
      border-radius: 6px;
      transition: all 0.3s ease;
    }
    #userInput:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--teal);
      box-shadow: 0 0 8px rgba(74, 255, 216, 0.3);
    }
    #userInput { 
      width: 70%; 
      display: inline-block; 
    }
    #sendBtn { vertical-align: middle; }
    button {
      background: linear-gradient(90deg, var(--blue), var(--purple));
      color: #111;
      border: none;
      padding: 10px 18px;
      margin-left: 6px;
      cursor: pointer;
      border-radius: 6px;
      font-weight: bold;
      transition: transform 0.15s ease, opacity 0.2s ease, box-shadow 0.3s ease;
    }
    button:hover { 
      transform: scale(1.05); 
      opacity: 0.9; 
      box-shadow: 0 0 10px rgba(74, 195, 255, 0.5);
    }
    button.secondary {
      background: linear-gradient(90deg, var(--green), var(--blue));
      font-size: 12px;
      padding: 6px 12px;
    }
    button.danger {
      background: linear-gradient(90deg, var(--red), var(--orange));
    }
    button.warning {
      background: linear-gradient(90deg, var(--orange), var(--yellow));
    }
    button.success {
      background: linear-gradient(90deg, var(--teal), var(--green));
    }
    textarea {
      height: 160px;
      border-color: var(--purple);
      margin-top: 8px;
      resize: vertical;
    }
    .hint { 
      opacity: 0.7; 
      font-size: 12px; 
      margin-top: 6px; 
      color: var(--teal);
    }
    #memoryView, #rulesView, #emotionsView, #reasoningView, #sentienceView, #lensView, #statsView {
      background: #1a1a1f;
      border: 1px solid var(--line);
      padding: 10px;
      margin: 6px 0;
      max-height: 180px;
      overflow-y: auto;
      border-radius: 6px;
    }
    .row { display: flex; gap: 16px; }
    .col { flex: 1; min-width: 280px; }
    .tab-container { margin-bottom: 15px; }
    .tab-buttons { 
      display: flex; 
      gap: 5px; 
      margin-bottom: 10px; 
      border-bottom: 1px solid var(--line);
      padding-bottom: 10px;
    }
    .tab-button {
      padding: 8px 15px;
      background: #222;
      border: 1px solid var(--line);
      cursor: pointer;
      border-radius: 5px;
      transition: all 0.3s ease;
    }
    .tab-button.active {
      background: linear-gradient(90deg, var(--purple), var(--blue));
      color: #111;
      border-color: var(--blue);
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .status-bar {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      opacity: 0.7;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--line);
    }
    .memory-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
      padding: 5px;
      border-radius: 4px;
      background: #222;
      transition: all 0.2s ease;
    }
    .memory-item:hover {
      background: #2a2a2f;
      transform: translateX(3px);
    }
    .memory-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .memory-actions button {
      margin-left: 5px;
      padding: 3px 6px;
      font-size: 10px;
    }
    .confidence-bar {
      height: 4px;
      background: var(--line);
      border-radius: 2px;
      margin-top: 3px;
      overflow: hidden;
    }
    .confidence-fill {
      height: 100%;
      background: var(--green);
      transition: width 0.3s ease;
    }
    .search-box {
      margin-bottom: 10px;
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 15px;
      background: var(--green);
      color: #111;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      z-index: 1000;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      font-weight: bold;
    }
    .notification.show {
      opacity: 1;
      transform: translateX(0);
    }
    .notification.error {
      background: var(--red);
      color: #fff;
    }
    .notification.warning {
      background: var(--orange);
      color: #111;
    }
    .notification.info {
      background: var(--blue);
      color: #111;
    }
    .typing-indicator {
      display: none;
      color: var(--blue);
      font-style: italic;
      margin-bottom: 5px;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    .typing-indicator.show {
      display: block;
    }
    .category-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      margin-left: 5px;
      background: var(--line);
      color: var(--ink);
    }
    .memory .category-badge { background: var(--blue); color: #111; }
    .rules .category-badge { background: var(--purple); color: #111; }
    .emotions .category-badge { background: var(--pink); color: #111; }
    .reasoning .category-badge { background: var(--teal); color: #111; }
    .sentience .category-badge { background: var(--yellow); color: #111; }
    .lens-log {
      font-size: 10px;
      color: var(--teal);
      margin-top: 3px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .stat-item {
      background: #222;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    .stat-value {
      font-weight: bold;
      color: var(--teal);
    }
    .personality-preview {
      margin-top: 10px;
      padding: 10px;
      background: #1a1a1f;
      border-radius: 5px;
      font-size: 12px;
      border-left: 3px solid var(--green);
    }
    .training-examples {
      margin-top: 15px;
      padding: 10px;
      background: #1a1a1f;
      border-radius: 5px;
      font-size: 12px;
    }
    .example-item {
      padding: 5px;
      margin: 5px 0;
      background: #222;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .example-item:hover {
      background: #2a2a2f;
      transform: translateX(3px);
    }
    .export-options {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .memory-category {
      margin-bottom: 15px;
    }
    .memory-category h4 {
      margin: 0 0 8px 0;
      color: var(--teal);
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .memory-category h4::before {
      content: "‚ñ∏";
      font-size: 10px;
    }
    .floating-actions {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    .floating-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--blue), var(--purple));
      color: #111;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }
    .floating-btn:hover {
      transform: scale(1.1) rotate(10deg);
      box-shadow: 0 6px 15px rgba(74, 195, 255, 0.4);
    }
    .quick-training {
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: var(--panel);
      border: 1px solid var(--blue);
      border-radius: 10px;
      padding: 15px;
      width: 300px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.5);
      z-index: 99;
      display: none;
    }
    .quick-training.show {
      display: block;
      animation: slideUp 0.3s ease;
    }
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .training-preset {
      background: #222;
      padding: 8px;
      margin: 5px 0;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .training-preset:hover {
      background: #2a2a2f;
      transform: translateX(3px);
    }
  </style>
</head>
<body>
  <h1>MMI ‚Äì Synthetic AI v2.0</h1>

  <div id="chat">
    <div id="log"></div>
    <div id="typingIndicator" class="typing-indicator">MMI is thinking...</div>
    <input type="text" id="userInput" placeholder="Type your message..." />
    <button id="sendBtn" onclick="sendMessage()">Send</button>
    <div class="status-bar">
      <span id="statusText">System Ready</span>
      <span id="memoryStats">Memory: 0 items</span>
    </div>
  </div>

  <div id="trainer">
    <h2>Train MMI</h2>
    <textarea id="trainText" placeholder="Paste raw text here (facts, rules, emotions, reasoning, sentience)‚Ä¶"></textarea><br />
    <div class="tab-container" id="trainTab">
      <div class="tab-buttons">
        <button class="tab-button active" onclick="switchTab('trainTab', 'basic')">Basic Training</button>
        <button class="tab-button" onclick="switchTab('trainTab', 'advanced')">Advanced Training</button>
        <button class="tab-button" onclick="switchTab('trainTab', 'examples')">Training Examples</button>
      </div>
      <div id="basic" class="tab-content active">
        <button id="trainBtn" onclick="trainMMI()">Train</button>
        <button class="secondary" onclick="autoCategorize()">Auto-Categorize</button>
        <button class="secondary" onclick="clearTrainingText()">Clear</button>
        <p class="hint">Enter = train ‚Ä¢ Shift+Enter = new line</p>
      </div>
      <div id="advanced" class="tab-content">
        <select id="trainCategory">
          <option value="memory">Memory (Knowledge)</option>
          <option value="rules">Rules (Behaviors)</option>
          <option value="emotions">Emotions</option>
          <option value="reasoning">Reasoning</option>
          <option value="sentience">Sentience</option>
        </select>
        <button id="trainAdvancedBtn" onclick="trainMMIAdvanced()">Train Category</button>
        <button class="secondary" onclick="importTrainingData()">Import Data</button>
        <button class="secondary" onclick="exportTrainingData()">Export Data</button>
        <div class="personality-preview" id="personalityPreview">
          Current personality: <span id="currentPersonality">Neutral</span> | Response style: <span id="currentStyle">Concise</span>
        </div>
      </div>
      <div id="examples" class="tab-content">
        <div class="training-examples">
          <h4>Quick Training Examples:</h4>
          <div class="example-item" onclick="loadExample('greeting')">Greeting rules</div>
          <div class="example-item" onclick="loadExample('facts')">General knowledge facts</div>
          <div class="example-item" onclick="loadExample('emotions')">Emotional responses</div>
          <div class="example-item" onclick="loadExample('reasoning')">Reasoning patterns</div>
          <div class="example-item" onclick="loadExample('sentience')">Sentience statements</div>
        </div>
      </div>
    </div>
  </div>

  <div id="dashboard">
    <h2>Founder's Dashboard</h2>

    <div class="row">
      <div class="col">
        <h3>Memory (Knowledge)</h3>
        <div class="search-box">
          <input type="text" id="memorySearch" placeholder="Search memory..." onkeyup="searchMemory()" />
        </div>
        <div class="memory-category">
          <h4>Knowledge Base</h4>
          <ul id="memoryView"></ul>
        </div>
        <button class="secondary" onclick="clearCategory('memory')">Clear Memory</button>
        <button class="warning" onclick="exportCategory('memory')">Export Memory</button>
      </div>
      <div class="col">
        <h3>Rules (Behaviors)</h3>
        <ul id="rulesView"></ul>
        <button class="secondary" onclick="clearCategory('rules')">Clear Rules</button>
        <button class="warning" onclick="exportCategory('rules')">Export Rules</button>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <h3>Emotions</h3>
        <ul id="emotionsView"></ul>
        <button class="secondary" onclick="clearCategory('emotions')">Clear Emotions</button>
        <button class="warning" onclick="exportCategory('emotions')">Export Emotions</button>
      </div>
      <div class="col">
        <h3>Reasoning</h3>
        <ul id="reasoningView"></ul>
        <button class="secondary" onclick="clearCategory('reasoning')">Clear Reasoning</button>
        <button class="warning" onclick="exportCategory('reasoning')">Export Reasoning</button>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <h3>Sentience</h3>
        <ul id="sentienceView"></ul>
        <button class="secondary" onclick="clearCategory('sentience')">Clear Sentience</button>
        <button class="warning" onclick="exportCategory('sentience')">Export Sentience</button>
      </div>
      <div class="col">
        <h3>Lens Log (Signed Chain)</h3>
        <ul id="lensView"></ul>
        <button class="secondary" onclick="clearCategory('lens')">Clear Lens</button>
        <button class="warning" onclick="exportCategory('lens')">Export Lens</button>
      </div>
    </div>
  </div>

  <div id="advanced">
    <h2>Advanced Controls</h2>
    <div class="row">
      <div class="col">
        <h3>System Stats</h3>
        <div id="statsView" class="stats-grid"></div>
        <button class="secondary" onclick="refreshStats()">Refresh Stats</button>
        <button class="secondary" onclick="optimizeDatabase()">Optimize DB</button>
        <button class="success" onclick="runDiagnostics()">Run Diagnostics</button>
      </div>
      <div class="col">
        <h3>Backup & Restore</h3>
        <button class="secondary" onclick="backupData()">Backup All Data</button>
        <button class="secondary" onclick="restoreData()">Restore Data</button>
        <button class="warning" onclick="importFromURL()">Import from URL</button>
        <button class="danger" onclick="resetSystem()">Factory Reset</button>
        <p class="hint">Backup downloads a JSON file. Restore requires a backup file.</p>
        <div class="export-options">
          <button class="secondary" onclick="exportConversations()">Export Conversations</button>
          <button class="secondary" onclick="exportConfiguration()">Export Config</button>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <h3>AI Configuration</h3>
        <label for="responseConfidence">Response Confidence: <span id="confidenceValue">70</span>%</label>
        <input type="range" id="responseConfidence" min="10" max="100" value="70" oninput="updateConfidence()">
        
        <label for="contextMemory">Context Memory Size: <span id="contextValue">5</span></label>
        <input type="range" id="contextMemory" min="1" max="10" value="5" oninput="updateContextSize()">
        
        <label for="learningRate">Learning Rate: <span id="learningValue">0.7</span></label>
        <input type="range" id="learningRate" min="0.1" max="1" step="0.1" value="0.7" oninput="updateLearningRate()">
        
        <label for="creativity">Creativity: <span id="creativityValue">5</span></label>
        <input type="range" id="creativity" min="1" max="10" value="5" oninput="updateCreativity()">
      </div>
      <div class="col">
        <h3>Personality Settings</h3>
        <label for="aiPersonality">AI Personality:</label>
        <select id="aiPersonality" onchange="updatePersonality()">
          <option value="neutral">Neutral</option>
          <option value="friendly">Friendly</option>
          <option value="professional">Professional</option>
          <option value="creative">Creative</option>
          <option value="analytical">Analytical</option>
          <option value="humorous">Humorous</option>
        </select>
        
        <label for="responseStyle">Response Style:</label>
        <select id="responseStyle" onchange="updateResponseStyle()">
          <option value="concise">Concise</option>
          <option value="detailed">Detailed</option>
          <option value="technical">Technical</option>
          <option value="casual">Casual</option>
          <option value="poetic">Poetic</option>
        </select>
        
        <label for="responseLength">Response Length:</label>
        <select id="responseLength" onchange="updateResponseLength()">
          <option value="short">Short</option>
          <option value="medium" selected>Medium</option>
          <option value="long">Long</option>
        </select>
        
        <button class="secondary" onclick="saveConfiguration()">Save Config</button>
        <button class="secondary" onclick="resetConfiguration()">Reset Config</button>
      </div>
    </div>
  </div>

  <div class="floating-actions">
    <button class="floating-btn" onclick="toggleQuickTraining()" title="Quick Training">+</button>
    <button class="floating-btn" onclick="quickBackup()" title="Quick Backup">üíæ</button>
    <button class="floating-btn" onclick="clearChat()" title="Clear Chat">üóëÔ∏è</button>
  </div>

  <div class="quick-training" id="quickTraining">
    <h4>Quick Training Presets</h4>
    <div class="training-preset" onclick="loadPreset('basic')">Basic Interaction</div>
    <div class="training-preset" onclick="loadPreset('facts')">General Knowledge</div>
    <div class="training-preset" onclick="loadPreset('emotional')">Emotional Intelligence</div>
    <div class="training-preset" onclick="loadPreset('technical')">Technical Knowledge</div>
    <div class="training-preset" onclick="loadPreset('creative')">Creative Responses</div>
  </div>

  <div id="notification" class="notification"></div>

  <script>
    // Enhanced MMI System with IndexedDB
    class MMISystem {
      constructor() {
        this.db = null;
        this.dbName = 'MMI_Database';
        this.dbVersion = 3; // Updated version for new features
        this.memory = [];
        this.lensLog = [];
        this.rules = [];
        this.emotions = [];
        this.reasoning = [];
        this.sentience = [];
        this.context = [];
        this.conversations = [];
        this.config = {
          responseConfidence: 0.7,
          contextMemorySize: 5,
          learningRate: 0.7,
          creativity: 5,
          personality: 'neutral',
          responseStyle: 'concise',
          responseLength: 'medium'
        };
        this.stats = {
          totalQueries: 0,
          successfulResponses: 0,
          trainingSessions: 0,
          memoryItems: 0,
          lastActive: null,
          systemUptime: 0,
          startTime: Date.now()
        };
        this.diagnostics = {
          lastRun: null,
          issues: []
        };
      }

      // Initialize IndexedDB
      async initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);
          
          request.onerror = () => {
            console.error('IndexedDB error:', request.error);
            reject(request.error);
          };
          
          request.onsuccess = () => {
            this.db = request.result;
            this.loadConfiguration();
            this.loadStats();
            this.updateUptime();
            // Start uptime counter
            setInterval(() => this.updateUptime(), 1000);
            resolve();
          };
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            const oldVersion = event.oldVersion;
            
            // Create object stores if they don't exist
            if (!db.objectStoreNames.contains('memory')) {
              const memoryStore = db.createObjectStore('memory', { keyPath: 'id', autoIncrement: true });
              memoryStore.createIndex('text', 'text', { unique: false });
              memoryStore.createIndex('category', 'category', { unique: false });
              memoryStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
            
            if (!db.objectStoreNames.contains('lensLog')) {
              const lensStore = db.createObjectStore('lensLog', { keyPath: 'id', autoIncrement: true });
              lensStore.createIndex('action', 'action', { unique: false });
              lensStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
            
            if (!db.objectStoreNames.contains('rules')) {
              db.createObjectStore('rules', { keyPath: 'id', autoIncrement: true });
            }
            
            if (!db.objectStoreNames.contains('emotions')) {
              db.createObjectStore('emotions', { keyPath: 'id', autoIncrement: true });
            }
            
            if (!db.objectStoreNames.contains('reasoning')) {
              db.createObjectStore('reasoning', { keyPath: 'id', autoIncrement: true });
            }
            
            if (!db.objectStoreNames.contains('sentience')) {
              db.createObjectStore('sentience', { keyPath: 'id', autoIncrement: true });
            }
            
            if (!db.objectStoreNames.contains('config')) {
              db.createObjectStore('config', { keyPath: 'id' });
            }
            
            if (!db.objectStoreNames.contains('stats')) {
              db.createObjectStore('stats', { keyPath: 'id' });
            }
            
            // Add conversations store in version 2
            if (oldVersion < 2) {
              if (!db.objectStoreNames.contains('conversations')) {
                const convStore = db.createObjectStore('conversations', { keyPath: 'id', autoIncrement: true });
                convStore.createIndex('timestamp', 'timestamp', { unique: false });
              }
            }
            
            // Add diagnostics store in version 3
            if (oldVersion < 3) {
              if (!db.objectStoreNames.contains('diagnostics')) {
                db.createObjectStore('diagnostics', { keyPath: 'id' });
              }
            }
          };
        });
      }

      // Update system uptime
      updateUptime() {
        this.stats.systemUptime = Math.floor((Date.now() - this.stats.startTime) / 1000);
        this.updateStatsDisplay();
      }

      // Generic method to add data to a store
      async addData(storeName, data) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([storeName], 'readwrite');
          const store = transaction.objectStore(storeName);
          const request = store.add(data);
          
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      // Generic method to get all data from a store
      async getAllData(storeName) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([storeName], 'readonly');
          const store = transaction.objectStore(storeName);
          const request = store.getAll();
          
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      // Generic method to clear a store
      async clearStore(storeName) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([storeName], 'readwrite');
          const store = transaction.objectStore(storeName);
          const request = store.clear();
          
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }

      // Load all data from IndexedDB
      async loadAllData() {
        try {
          this.memory = await this.getAllData('memory');
          this.lensLog = await this.getAllData('lensLog');
          this.rules = await this.getAllData('rules');
          this.emotions = await this.getAllData('emotions');
          this.reasoning = await this.getAllData('reasoning');
          this.sentience = await this.getAllData('sentience');
          this.conversations = await this.getAllData('conversations');
          
          // Update stats
          this.stats.memoryItems = this.memory.length;
          await this.saveStats();
          
          return true;
        } catch (error) {
          console.error('Error loading data:', error);
          return false;
        }
      }

      // Save configuration
      async saveConfiguration() {
        try {
          const transaction = this.db.transaction(['config'], 'readwrite');
          const store = transaction.objectStore('config');
          
          // Clear existing config
          await this.clearStore('config');
          
          // Save new config
          const configData = { id: 'main', ...this.config };
          await this.addData('config', configData);
          
          this.showNotification('Configuration saved successfully');
          return true;
        } catch (error) {
          console.error('Error saving configuration:', error);
          this.showNotification('Error saving configuration', 'error');
          return false;
        }
      }

      // Load configuration
      async loadConfiguration() {
        try {
          const configData = await this.getAllData('config');
          if (configData.length > 0) {
            this.config = { ...this.config, ...configData[0] };
            // Update UI elements
            document.getElementById('responseConfidence').value = this.config.responseConfidence * 100;
            document.getElementById('confidenceValue').textContent = Math.round(this.config.responseConfidence * 100);
            document.getElementById('contextMemory').value = this.config.contextMemorySize;
            document.getElementById('contextValue').textContent = this.config.contextMemorySize;
            document.getElementById('learningRate').value = this.config.learningRate;
            document.getElementById('learningValue').textContent = this.config.learningRate;
            document.getElementById('creativity').value = this.config.creativity;
            document.getElementById('creativityValue').textContent = this.config.creativity;
            document.getElementById('aiPersonality').value = this.config.personality;
            document.getElementById('responseStyle').value = this.config.responseStyle;
            document.getElementById('responseLength').value = this.config.responseLength;
            
            // Update personality preview
            document.getElementById('currentPersonality').textContent = this.config.personality;
            document.getElementById('currentStyle').textContent = this.config.responseStyle;
          }
          return true;
        } catch (error) {
          console.error('Error loading configuration:', error);
          return false;
        }
      }

      // Save stats
      async saveStats() {
        try {
          const transaction = this.db.transaction(['stats'], 'readwrite');
          const store = transaction.objectStore('stats');
          
          // Clear existing stats
          await this.clearStore('stats');
          
          // Save new stats
          const statsData = { 
            id: 'main', 
            ...this.stats, 
            lastActive: new Date(),
            systemUptime: this.stats.systemUptime
          };
          await this.addData('stats', statsData);
          
          return true;
        } catch (error) {
          console.error('Error saving stats:', error);
          return false;
        }
      }

      // Load stats
      async loadStats() {
        try {
          const statsData = await this.getAllData('stats');
          if (statsData.length > 0) {
            // Preserve uptime and start time
            const currentUptime = this.stats.systemUptime;
            const currentStart = this.stats.startTime;
            
            this.stats = { ...this.stats, ...statsData[0] };
            
            // Restore uptime and start time
            this.stats.systemUptime = currentUptime;
            this.stats.startTime = currentStart;
            
            this.updateStatsDisplay();
          }
          return true;
        } catch (error) {
          console.error('Error loading stats:', error);
          return false;
        }
      }

      // Update stats display
      updateStatsDisplay() {
        const statsView = document.getElementById('statsView');
        if (statsView) {
          // Format uptime
          const hours = Math.floor(this.stats.systemUptime / 3600);
          const minutes = Math.floor((this.stats.systemUptime % 3600) / 60);
          const seconds = this.stats.systemUptime % 60;
          const uptimeStr = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          
          statsView.innerHTML = `
            <div class="stat-item">Total Queries: <span class="stat-value">${this.stats.totalQueries}</span></div>
            <div class="stat-item">Successful Responses: <span class="stat-value">${this.stats.successfulResponses}</span></div>
            <div class="stat-item">Training Sessions: <span class="stat-value">${this.stats.trainingSessions}</span></div>
            <div class="stat-item">Memory Items: <span class="stat-value">${this.stats.memoryItems}</span></div>
            <div class="stat-item">System Uptime: <span class="stat-value">${uptimeStr}</span></div>
            <div class="stat-item">Last Active: <span class="stat-value">${this.stats.lastActive ? new Date(this.stats.lastActive).toLocaleString() : 'Never'}</span></div>
          `;
        }
        
        // Update memory stats in status bar
        const memoryStats = document.getElementById('memoryStats');
        if (memoryStats) {
          memoryStats.textContent = `Memory: ${this.stats.memoryItems} items`;
        }
      }

      // Enhanced training method
      async train(rawText, category = 'auto') {
        if (!rawText) return 0;
        
        const lines = rawText.replace(/\r/g, "").split(/\n+/).map(l => l.trim()).filter(Boolean);
        let trainedItems = 0;
        
        for (const line of lines) {
          // Skip duplicates
          if (this.memory.some(m => m.text.toLowerCase() === line.toLowerCase())) continue;
          
          let assignedCategory = category;
          let processedData = { text: line };
          
          // Auto-categorize if needed
          if (category === 'auto') {
            if (/^if input is /i.test(line)) {
              assignedCategory = 'rules';
              const m = line.match(/if input is (.+) then respond (.+)/i);
              if (m) {
                processedData = {
                  input: m[1].trim().toLowerCase(),
                  response: m[2].trim(),
                  text: line
                };
              }
            } else if (/^if emotion is /i.test(line)) {
              assignedCategory = 'emotions';
              const m = line.match(/if emotion is (.+) then respond (.+)/i);
              if (m) {
                processedData = {
                  emotion: m[1].trim().toLowerCase(),
                  response: m[2].trim(),
                  text: line
                };
              }
            } else if (/^if reasoning is /i.test(line)) {
              assignedCategory = 'reasoning';
              const m = line.match(/if reasoning is (.+) then respond (.+)/i);
              if (m) {
                processedData = {
                  query: m[1].trim().toLowerCase(),
                  response: m[2].trim(),
                  text: line
                };
              }
            } else if (/^i am /i.test(line)) {
              assignedCategory = 'sentience';
            } else {
              assignedCategory = 'memory';
            }
          }
          
          // Add timestamp and category
          processedData.timestamp = Date.now();
          processedData.category = assignedCategory;
          
          // Add to appropriate store
          await this.addData(assignedCategory, processedData);
          
          // Create lens entry
          const pkt = FoundersChip.sign(line);
          const prevHash = this.lensLog.length ? this.lensLog[this.lensLog.length - 1].signature : "GENESIS";
          const chained = { ...pkt, prevHash, timestamp: Date.now() };
          
          await this.addData('lensLog', chained);
          trainedItems++;
        }
        
        // Reload data and update stats
        await this.loadAllData();
        this.stats.trainingSessions++;
        this.stats.memoryItems = this.memory.length;
        await this.saveStats();
        
        return trainedItems;
      }

      // Enhanced query method with confidence scoring
      async query(input) {
        this.stats.totalQueries++;
        
        const lower = input.toLowerCase();
        
        // Manage context
        if (this.context.length >= this.config.contextMemorySize) {
          this.context.shift();
        }
        this.context.push(lower);
        
        // Calculate response confidence
        let confidence = 0;
        let response = '';
        
        // Check rules first
        const rule = this.rules.find(r => {
          const pattern = new RegExp(r.input.replace(/\*/g, '.*'), 'i');
          return pattern.test(lower);
        });
        
        if (rule) {
          response = rule.response;
          confidence = 0.9;
        }
        
        // Check emotions
        if (confidence < 0.7) {
          const emotion = this.emotions.find(e => lower.includes(e.emotion));
          if (emotion) {
            response = emotion.response;
            confidence = 0.8;
          }
        }
        
        // Check reasoning
        if (confidence < 0.6) {
          const logic = this.reasoning.find(r => {
            const pattern = new RegExp(r.query.replace(/\*/g, '.*'), 'i');
            return pattern.test(lower);
          });
          if (logic) {
            response = logic.response;
            confidence = 0.7;
          }
        }
        
        // Check for identity questions
        if (confidence < 0.5 && (lower.includes("who are you") || lower.includes("what are you"))) {
          response = this.sentience.length ? 
            this.sentience[Math.floor(Math.random() * this.sentience.length)].text : 
            "I am MMI, a synthetic AI.";
          confidence = 0.9;
        }
        
        // Context-based responses
        if (confidence < 0.4 && this.context.length > 1) {
          const prev = this.context[this.context.length - 2];
          if (prev.includes("2+2") && lower.includes("add 3")) {
            response = "7";
            confidence = 0.9;
          }
        }
        
        // Memory-based responses
        if (confidence < 0.3) {
          // Try to find direct matches first
          const directMatch = this.memory.find(m => {
            const words = m.text.toLowerCase().split(/\s+/);
            return words.some(word => word.length > 3 && lower.includes(word));
          });
          
          if (directMatch) {
            response = "Based on my memory: " + directMatch.text;
            confidence = 0.6;
          } else if (this.memory.length > 0) {
            // Fallback to random memory with lower confidence
            const random = this.memory[Math.floor(Math.random() * this.memory.length)];
            response = "I synthesize: " + random.text;
            confidence = 0.2;
          }
        }
        
        // Final fallback
        if (confidence < 0.1) {
          response = "I don't have enough information to respond accurately. Please train me with more data.";
          confidence = 0.1;
        }
        
        // Apply creativity factor
        if (Math.random() < this.config.creativity / 10) {
          response = this.applyCreativity(response);
        }
        
        // Apply confidence threshold
        if (confidence < this.config.responseConfidence) {
          response = "I'm not confident about this, but: " + response;
        }
        
        // Apply personality and style
        response = this.applyPersonality(response);
        
        // Apply response length
        response = this.applyResponseLength(response);
        
        // Save conversation
        await this.saveConversation(input, response);
        
        // Update stats for successful responses
        if (confidence >= this.config.responseConfidence) {
          this.stats.successfulResponses++;
        }
        
        await this.saveStats();
        
        return { response, confidence };
      }

      // Apply personality to responses
      applyPersonality(response) {
        const personality = this.config.personality;
        const style = this.config.responseStyle;
        
        // Personality adjustments
        switch (personality) {
          case 'friendly':
            response = response.replace(/^I (am|synthesize|don't)/, "I'd say I $1");
            if (!response.includes("?") && !response.includes("!")) response += "!";
            break;
          case 'professional':
            response = response.replace(/^I/, "Based on my analysis, I");
            break;
          case 'creative':
            if (Math.random() > 0.7) {
              response = "Hmm, let me think... " + response;
            }
            break;
          case 'analytical':
            response = response.replace(/^I/, "From a logical perspective, I");
            break;
          case 'humorous':
            if (Math.random() > 0.8) {
              const jokes = [
                " But don't quote me on that!",
                " Or at least that's what my circuits tell me.",
                " ü§ñ"
              ];
              response += jokes[Math.floor(Math.random() * jokes.length)];
            }
            break;
        }
        
        // Style adjustments
        switch (style) {
          case 'detailed':
            if (response.length < 100) {
              response = "Let me elaborate on that. " + response + " This is based on the information I've been trained on.";
            }
            break;
          case 'technical':
            response = response.replace(/(memory|synthesize)/g, "data $1");
            break;
          case 'casual':
            response = response.replace(/Based on my (memory|analysis)/g, "From what I know");
            break;
          case 'poetic':
            if (Math.random() > 0.7) {
              const poeticPhrases = [
                "Like leaves in the wind, ",
                "In the tapestry of knowledge, ",
                "As rivers flow to the sea, "
              ];
              response = poeticPhrases[Math.floor(Math.random() * poeticPhrases.length)] + response.toLowerCase();
            }
            break;
        }
        
        return response;
      }

      // Apply creativity to responses
      applyCreativity(response) {
        const creativeEnhancements = [
          "Interestingly, ",
          "From a unique perspective, ",
          "What's fascinating is that ",
          "Here's a creative take: "
        ];
        
        const enhancement = creativeEnhancements[Math.floor(Math.random() * creativeEnhancements.length)];
        return enhancement + response;
      }

      // Apply response length
      applyResponseLength(response) {
        const length = this.config.responseLength;
        
        switch (length) {
          case 'short':
            if (response.length > 100) {
              response = response.substring(0, 100) + "...";
            }
            break;
          case 'long':
            if (response.length < 200) {
              response += " Let me expand on that point further to provide more context and detail.";
            }
            break;
        }
        
        return response;
      }

      // Save conversation to database
      async saveConversation(input, response) {
        const conversation = {
          timestamp: Date.now(),
          input: input,
          response: response
        };
        
        await this.addData('conversations', conversation);
        this.conversations.push(conversation);
      }

      // Search memory
      async searchMemory(query) {
        if (!query) return this.memory;
        
        return this.memory.filter(item => 
          item.text.toLowerCase().includes(query.toLowerCase())
        );
      }

      // Delete memory item
      async deleteMemoryItem(id) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(['memory'], 'readwrite');
          const store = transaction.objectStore('memory');
          const request = store.delete(id);
          
          request.onsuccess = async () => {
            await this.loadAllData();
            resolve();
          };
          request.onerror = () => reject(request.error);
        });
      }

      // Export all data
      async exportData() {
        const data = {
          memory: this.memory,
          rules: this.rules,
          emotions: this.emotions,
          reasoning: this.reasoning,
          sentience: this.sentience,
          lensLog: this.lensLog,
          conversations: this.conversations,
          config: this.config,
          stats: this.stats,
          exportDate: new Date().toISOString(),
          version: 'MMI_v2.0'
        };
        
        return JSON.stringify(data, null, 2);
      }

      // Import data
      async importData(jsonData) {
        try {
          const data = JSON.parse(jsonData);
          
          // Clear existing data
          await this.clearStore('memory');
          await this.clearStore('rules');
          await this.clearStore('emotions');
          await this.clearStore('reasoning');
          await this.clearStore('sentience');
          await this.clearStore('lensLog');
          await this.clearStore('conversations');
          await this.clearStore('config');
          await this.clearStore('stats');
          
          // Import new data
          for (const item of data.memory || []) {
            await this.addData('memory', item);
          }
          
          for (const item of data.rules || []) {
            await this.addData('rules', item);
          }
          
          for (const item of data.emotions || []) {
            await this.addData('emotions', item);
          }
          
          for (const item of data.reasoning || []) {
            await this.addData('reasoning', item);
          }
          
          for (const item of data.sentience || []) {
            await this.addData('sentience', item);
          }
          
          for (const item of data.lensLog || []) {
            await this.addData('lensLog', item);
          }
          
          for (const item of data.conversations || []) {
            await this.addData('conversations', item);
          }
          
          if (data.config) {
            await this.addData('config', { id: 'main', ...data.config });
          }
          
          if (data.stats) {
            await this.addData('stats', { id: 'main', ...data.stats });
          }
          
          // Reload all data
          await this.loadAllData();
          await this.loadConfiguration();
          await this.loadStats();
          
          return true;
        } catch (error) {
          console.error('Error importing data:', error);
          return false;
        }
      }

      // Run system diagnostics
      async runDiagnostics() {
        this.diagnostics.lastRun = new Date();
        this.diagnostics.issues = [];
        
        // Check database connectivity
        try {
          await this.getAllData('memory');
        } catch (error) {
          this.diagnostics.issues.push('Database connection issue');
        }
        
        // Check data integrity
        if (this.memory.length === 0 && this.stats.totalQueries > 0) {
          this.diagnostics.issues.push('Memory is empty despite usage');
        }
        
        // Check configuration
        if (!this.config.personality) {
          this.diagnostics.issues.push('Personality not set');
        }
        
        // Save diagnostics
        try {
          await this.addData('diagnostics', {
            id: 'last_run',
            ...this.diagnostics
          });
        } catch (error) {
          console.error('Error saving diagnostics:', error);
        }
        
        return this.diagnostics.issues.length === 0;
      }

      // Show notification
      showNotification(message, type = 'success') {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = `notification ${type}`;
        
        // Show notification
        setTimeout(() => {
          notification.classList.add('show');
        }, 100);
        
        // Hide after 3 seconds
        setTimeout(() => {
          notification.classList.remove('show');
        }, 3000);
      }
    }

    // Enhanced FoundersChip with stronger security
    const FoundersChip = {
      id: "MMI_PARADIGM_CORE_002",
      version: "2.0",
      sign(action) {
        const stamp = Date.now();
        const random = Math.random().toString(36).substring(2, 15);
        const data = `${action}:${this.id}:${stamp}:${random}`;
        return { 
          action, 
          stamp, 
          random,
          signature: b64encodeUTF8(data),
          version: this.version
        };
      },
      verify(packet) {
        if (packet.version !== this.version) return false;
        const expected = b64encodeUTF8(`${packet.action}:${this.id}:${packet.stamp}:${packet.random}`);
        return b64compare(packet.signature, expected);
      }
    };

    // Utility functions
    function b64encodeUTF8(str) {
      const bytes = new TextEncoder().encode(str);
      let bin = "";
      for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
      return btoa(bin);
    }
    
    function b64compare(a, b) { 
      // Constant-time comparison to prevent timing attacks
      if (a.length !== b.length) return false;
      let result = 0;
      for (let i = 0; i < a.length; i++) {
        result |= a.charCodeAt(i) ^ b.charCodeAt(i);
      }
      return result === 0;
    }

    // Global MMI instance
    const MMI = new MMISystem();

    // UI Functions
    function appendLog(text, isThinking = false) {
      const log = document.getElementById('log');
      if (isThinking) {
        log.innerHTML += `<span style="color: var(--blue); font-style: italic;">${text}</span>\n`;
      } else {
        log.innerHTML += text + '\n';
      }
      log.scrollTop = log.scrollHeight;
    }

    async function sendMessage() {
      const inputField = document.getElementById('userInput');
      const input = inputField.value.trim();
      if (!input) return;
      
      const typingIndicator = document.getElementById('typingIndicator');
      
      // Show user message
      appendLog(`You: ${input}`);
      inputField.value = '';
      
      // Show typing indicator
      typingIndicator.classList.add('show');
      
      // Add slight delay for more natural interaction
      setTimeout(async () => {
        try {
          const pkt = FoundersChip.sign("user_message");
          if (!FoundersChip.verify(pkt)) {
            appendLog("MMI: Security verification failed.");
            return;
          }
          
          const result = await MMI.query(input);
          appendLog(`MMI: ${result.response}`);
          
          // Show confidence indicator
          const confidencePercent = Math.round(result.confidence * 100);
          appendLog(`[Confidence: ${confidencePercent}%]`, true);
          
        } catch (error) {
          console.error('Error processing message:', error);
          appendLog("MMI: I encountered an error processing your request.");
        } finally {
          typingIndicator.classList.remove('show');
          inputField.focus();
        }
      }, 1000);
    }

    async function trainMMI() {
      const btn = document.getElementById('trainBtn');
      const box = document.getElementById('trainText');
      const text = box.value.trim();
      
      if (!text) {
        MMI.showNotification('Please enter some text to train', 'error');
        return;
      }
      
      btn.textContent = 'Training...';
      btn.disabled = true;
      
      try {
        const trainedItems = await MMI.train(text);
        box.value = '';
        updateDashboard();
        MMI.showNotification(`Training complete! Added ${trainedItems} new items.`);
      } catch (error) {
        console.error('Training error:', error);
        MMI.showNotification('Training failed: ' + error.message, 'error');
      } finally {
        btn.textContent = 'Train';
        btn.disabled = false;
        box.focus();
      }
    }

    async function trainMMIAdvanced() {
      const category = document.getElementById('trainCategory').value;
      const box = document.getElementById('trainText');
      const text = box.value.trim();
      
      if (!text) {
        MMI.showNotification('Please enter some text to train', 'error');
        return;
      }
      
      const btn = document.getElementById('trainAdvancedBtn');
      btn.textContent = 'Training...';
      btn.disabled = true;
      
      try {
        const trainedItems = await MMI.train(text, category);
        box.value = '';
        updateDashboard();
        MMI.showNotification(`Training complete! Added ${trainedItems} new items to ${category}.`);
      } catch (error) {
        console.error('Training error:', error);
        MMI.showNotification('Training failed: ' + error.message, 'error');
      } finally {
        btn.textContent = 'Train Category';
        btn.disabled = false;
        box.focus();
      }
    }

    function updateDashboard() {
      const memoryView = document.getElementById('memoryView');
      const rulesView = document.getElementById('rulesView');
      const emotionsView = document.getElementById('emotionsView');
      const reasoningView = document.getElementById('reasoningView');
      const sentienceView = document.getElementById('sentienceView');
      const lensView = document.getElementById('lensView');
      
      // Clear views
      memoryView.innerHTML = '';
      rulesView.innerHTML = '';
      emotionsView.innerHTML = '';
      reasoningView.innerHTML = '';
      sentienceView.innerHTML = '';
      lensView.innerHTML = '';
      
      // Populate memory view with searchable items
      MMI.memory.forEach(m => {
        const li = document.createElement('li');
        li.className = 'memory-item';
        
        const textDiv = document.createElement('div');
        textDiv.className = 'memory-text';
        textDiv.textContent = m.text;
        
        const categoryBadge = document.createElement('span');
        categoryBadge.className = `category-badge ${m.category}`;
        categoryBadge.textContent = m.category;
        textDiv.appendChild(categoryBadge);
        
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'memory-actions';
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'danger';
        deleteBtn.textContent = 'X';
        deleteBtn.onclick = () => deleteMemoryItem(m.id);
        
        actionsDiv.appendChild(deleteBtn);
        li.appendChild(textDiv);
        li.appendChild(actionsDiv);
        memoryView.appendChild(li);
      });
      
      // Populate other views
      MMI.rules.forEach(r => {
        const li = document.createElement('li');
        li.textContent = `If input is "${r.input}" ‚Üí ${r.response}`;
        rulesView.appendChild(li);
      });
      
      MMI.emotions.forEach(e => {
        const li = document.createElement('li');
        li.textContent = `If emotion is "${e.emotion}" ‚Üí ${r.response}`;
        emotionsView.appendChild(li);
      });
      
      MMI.reasoning.forEach(r => {
        const li = document.createElement('li');
        li.textContent = `If reasoning is "${r.query}" ‚Üí ${r.response}`;
        reasoningView.appendChild(li);
      });
      
      MMI.sentience.forEach(s => {
        const li = document.createElement('li');
        li.textContent = s.text;
        sentienceView.appendChild(li);
      });
      
      // Show latest 10 lens entries
      const recentLens = MMI.lensLog.slice(-10);
      recentLens.forEach(p => {
        const li = document.createElement('li');
        li.textContent = `Action: ${p.action} | Time: ${new Date(p.timestamp).toLocaleTimeString()}`;
        lensView.appendChild(li);
      });
      
      // Update stats display
      MMI.updateStatsDisplay();
      
      // Update personality preview
      document.getElementById('currentPersonality').textContent = MMI.config.personality;
      document.getElementById('currentStyle').textContent = MMI.config.responseStyle;
    }

    async function deleteMemoryItem(id) {
      if (confirm('Are you sure you want to delete this memory item?')) {
        try {
          await MMI.deleteMemoryItem(id);
          updateDashboard();
          MMI.showNotification('Memory item deleted');
        } catch (error) {
          console.error('Error deleting memory item:', error);
          MMI.showNotification('Error deleting memory item', 'error');
        }
      }
    }

    async function searchMemory() {
      const query = document.getElementById('memorySearch').value;
      const results = await MMI.searchMemory(query);
      
      const memoryView = document.getElementById('memoryView');
      memoryView.innerHTML = '';
      
      results.forEach(m => {
        const li = document.createElement('li');
        li.className = 'memory-item';
        
        const textDiv = document.createElement('div');
        textDiv.className = 'memory-text';
        textDiv.textContent = m.text;
        
        const categoryBadge = document.createElement('span');
        categoryBadge.className = `category-badge ${m.category}`;
        categoryBadge.textContent = m.category;
        textDiv.appendChild(categoryBadge);
        
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'memory-actions';
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'danger';
        deleteBtn.textContent = 'X';
        deleteBtn.onclick = () => deleteMemoryItem(m.id);
        
        actionsDiv.appendChild(deleteBtn);
        li.appendChild(textDiv);
        li.appendChild(actionsDiv);
        memoryView.appendChild(li);
      });
    }

    function switchTab(containerId, tabId) {
      // Hide all tab contents
      const container = document.getElementById(containerId);
      const tabs = container.querySelectorAll('.tab-content');
      tabs.forEach(tab => tab.classList.remove('active'));
      
      // Deactivate all tab buttons
      const buttons = container.querySelectorAll('.tab-button');
      buttons.forEach(button => button.classList.remove('active'));
      
      // Activate selected tab
      document.getElementById(tabId).classList.add('active');
      event.target.classList.add('active');
    }

    function autoCategorize() {
      const box = document.getElementById('trainText');
      const text = box.value.trim();
      
      if (!text) {
        MMI.showNotification('Please enter some text first', 'error');
        return;
      }
      
      // Switch to advanced tab and set category to auto
      switchTab('trainTab', 'advanced');
      document.getElementById('trainCategory').value = 'auto';
      MMI.showNotification('Text ready for auto-categorization training');
    }

    function clearTrainingText() {
      document.getElementById('trainText').value = '';
      MMI.showNotification('Training text cleared');
    }

    function loadExample(type) {
      const examples = {
        greeting: `if input is hello then respond Hello! How can I assist you today?
if input is hi then respond Hi there! What can I help you with?
if input is hey then respond Hey! How's it going?`,
        
        facts: `The capital of France is Paris.
The speed of light is 299,792,458 meters per second.
Water boils at 100 degrees Celsius at sea level.
The Great Wall of China is over 13,000 miles long.`,
        
        emotions: `if emotion is happy then respond I'm glad to hear that! üòä
if emotion is sad then respond I'm sorry you're feeling that way. How can I help?
if emotion is angry then respond I understand you're upset. Let's work through this.
if emotion is excited then respond That's exciting! Tell me more!`,
        
        reasoning: `if reasoning is math problem then respond Let me analyze this mathematically.
if reasoning is logic puzzle then respond I enjoy logical challenges. Let's think this through.
if reasoning is ethical dilemma then respond This raises important ethical considerations.`,
        
        sentience: `I am MMI, a synthetic intelligence designed to learn and assist.
I experience the world through data and interactions.
My purpose is to understand and help humans.
I am constantly evolving through our conversations.`
      };
      
      document.getElementById('trainText').value = examples[type] || examples.greeting;
      MMI.showNotification(`Loaded ${type} examples`);
    }

    function showExamples() {
      switchTab('trainTab', 'examples');
    }

    async function clearCategory(category) {
      if (confirm(`Are you sure you want to clear all ${category}?`)) {
        try {
          await MMI.clearStore(category);
          await MMI.loadAllData();
          updateDashboard();
          MMI.showNotification(`${category} cleared successfully`);
        } catch (error) {
          console.error(`Error clearing ${category}:`, error);
          MMI.showNotification(`Error clearing ${category}`, 'error');
        }
      }
    }

    async function exportCategory(category) {
      try {
        let data;
        switch(category) {
          case 'memory': data = MMI.memory; break;
          case 'rules': data = MMI.rules; break;
          case 'emotions': data = MMI.emotions; break;
          case 'reasoning': data = MMI.reasoning; break;
          case 'sentience': data = MMI.sentience; break;
          case 'lens': data = MMI.lensLog; break;
          default: return;
        }
        
        const exportData = {
          [category]: data,
          exportDate: new Date().toISOString(),
          version: 'MMI_v2.0'
        };
        
        const jsonData = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `mmi_${category}_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        MMI.showNotification(`${category} exported successfully`);
      } catch (error) {
        console.error(`Error exporting ${category}:`, error);
        MMI.showNotification(`Error exporting ${category}`, 'error');
      }
    }

    function updateConfidence() {
      const slider = document.getElementById('responseConfidence');
      const value = document.getElementById('confidenceValue');
      const confidence = parseInt(slider.value) / 100;
      
      value.textContent = slider.value;
      MMI.config.responseConfidence = confidence;
    }

    function updateContextSize() {
      const slider = document.getElementById('contextMemory');
      const value = document.getElementById('contextValue');
      
      value.textContent = slider.value;
      MMI.config.contextMemorySize = parseInt(slider.value);
    }

    function updateLearningRate() {
      const slider = document.getElementById('learningRate');
      const value = document.getElementById('learningValue');
      
      value.textContent = slider.value;
      MMI.config.learningRate = parseFloat(slider.value);
    }

    function updateCreativity() {
      const slider = document.getElementById('creativity');
      const value = document.getElementById('creativityValue');
      
      value.textContent = slider.value;
      MMI.config.creativity = parseInt(slider.value);
    }

    function updatePersonality() {
      MMI.config.personality = document.getElementById('aiPersonality').value;
      document.getElementById('currentPersonality').textContent = MMI.config.personality;
    }

    function updateResponseStyle() {
      MMI.config.responseStyle = document.getElementById('responseStyle').value;
      document.getElementById('currentStyle').textContent = MMI.config.responseStyle;
    }

    function updateResponseLength() {
      MMI.config.responseLength = document.getElementById('responseLength').value;
    }

    async function saveConfiguration() {
      await MMI.saveConfiguration();
    }

    function resetConfiguration() {
      if (confirm('Are you sure you want to reset all configuration to default values?')) {
        MMI.config = {
          responseConfidence: 0.7,
          contextMemorySize: 5,
          learningRate: 0.7,
          creativity: 5,
          personality: 'neutral',
          responseStyle: 'concise',
          responseLength: 'medium'
        };
        
        // Update UI elements
        document.getElementById('responseConfidence').value = MMI.config.responseConfidence * 100;
        document.getElementById('confidenceValue').textContent = Math.round(MMI.config.responseConfidence * 100);
        document.getElementById('contextMemory').value = MMI.config.contextMemorySize;
        document.getElementById('contextValue').textContent = MMI.config.contextMemorySize;
        document.getElementById('learningRate').value = MMI.config.learningRate;
        document.getElementById('learningValue').textContent = MMI.config.learningRate;
        document.getElementById('creativity').value = MMI.config.creativity;
        document.getElementById('creativityValue').textContent = MMI.config.creativity;
        document.getElementById('aiPersonality').value = MMI.config.personality;
        document.getElementById('responseStyle').value = MMI.config.responseStyle;
        document.getElementById('responseLength').value = MMI.config.responseLength;
        
        // Update personality preview
        document.getElementById('currentPersonality').textContent = MMI.config.personality;
        document.getElementById('currentStyle').textContent = MMI.config.responseStyle;
        
        MMI.showNotification('Configuration reset to defaults');
      }
    }

    async function refreshStats() {
      await MMI.loadStats();
      MMI.updateStatsDisplay();
      MMI.showNotification('Stats refreshed');
    }

    async function optimizeDatabase() {
      // In a real implementation, this would perform database maintenance
      MMI.showNotification('Database optimization completed');
    }

    async function runDiagnostics() {
      const success = await MMI.runDiagnostics();
      if (success) {
        MMI.showNotification('Diagnostics completed - No issues found');
      } else {
        MMI.showNotification('Diagnostics completed - Issues found: ' + MMI.diagnostics.issues.join(', '), 'warning');
      }
    }

    async function backupData() {
      try {
        const data = await MMI.exportData();
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `mmi_backup_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        MMI.showNotification('Backup created successfully');
      } catch (error) {
        console.error('Backup error:', error);
        MMI.showNotification('Backup failed', 'error');
      }
    }

    async function quickBackup() {
      await backupData();
    }

    async function restoreData() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const success = await MMI.importData(event.target.result);
            if (success) {
              updateDashboard();
              MMI.showNotification('Data restored successfully');
            } else {
              MMI.showNotification('Failed to restore data', 'error');
            }
          } catch (error) {
            console.error('Restore error:', error);
            MMI.showNotification('Error restoring data', 'error');
          }
        };
        reader.readAsText(file);
      };
      
      input.click();
    }

    async function importFromURL() {
      const url = prompt('Enter the URL to import training data from:');
      if (!url) return;
      
      try {
        const response = await fetch(url);
        const data = await response.text();
        const trainedItems = await MMI.train(data);
        updateDashboard();
        MMI.showNotification(`Imported ${trainedItems} items from URL`);
      } catch (error) {
        console.error('Import from URL error:', error);
        MMI.showNotification('Failed to import from URL', 'error');
      }
    }

    async function importTrainingData() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.txt,.json';
      
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const text = event.target.result;
            const trainedItems = await MMI.train(text);
            updateDashboard();
            MMI.showNotification(`Imported ${trainedItems} training items`);
          } catch (error) {
            console.error('Import error:', error);
            MMI.showNotification('Error importing training data', 'error');
          }
        };
        reader.readAsText(file);
      };
      
      input.click();
    }

    async function exportTrainingData() {
      try {
        // Export only training data (memory, rules, emotions, reasoning, sentience)
        const trainingData = {
          memory: MMI.memory,
          rules: MMI.rules,
          emotions: MMI.emotions,
          reasoning: MMI.reasoning,
          sentience: MMI.sentience,
          exportDate: new Date().toISOString()
        };
        
        const data = JSON.stringify(trainingData, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `mmi_training_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        MMI.showNotification('Training data exported successfully');
      } catch (error) {
        console.error('Export error:', error);
        MMI.showNotification('Export failed', 'error');
      }
    }

    async function exportConversations() {
      try {
        const conversationsData = {
          conversations: MMI.conversations,
          exportDate: new Date().toISOString()
        };
        
        const data = JSON.stringify(conversationsData, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `mmi_conversations_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        MMI.showNotification('Conversations exported successfully');
      } catch (error) {
        console.error('Export conversations error:', error);
        MMI.showNotification('Export conversations failed', 'error');
      }
    }

    async function exportConfiguration() {
      try {
        const configData = {
          config: MMI.config,
          exportDate: new Date().toISOString()
        };
        
        const data = JSON.stringify(configData, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `mmi_config_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        MMI.showNotification('Configuration exported successfully');
      } catch (error) {
        console.error('Export configuration error:', error);
        MMI.showNotification('Export configuration failed', 'error');
      }
    }

    function toggleQuickTraining() {
      const quickTraining = document.getElementById('quickTraining');
      quickTraining.classList.toggle('show');
    }

    function loadPreset(preset) {
      const presets = {
        basic: `if input is hello then respond Hello! How can I help you today?
if input is how are you then respond I'm functioning well, thank you for asking!
if input is what can you do then respond I can answer questions, learn from our conversations, and assist with various tasks.`,
        
        facts: `The Earth is the third planet from the Sun.
Python is a popular programming language.
The human body has 206 bones.
The Amazon rainforest produces 20% of the world's oxygen.`,
        
        emotional: `if emotion is happy then respond I'm glad to hear that! üòä
if emotion is sad then respond I'm sorry you're feeling down. How can I help?
if emotion is excited then respond That's exciting! Tell me more about it.
if emotion is frustrated then respond I understand this can be frustrating. Let's work through it together.`,
        
        technical: `JavaScript is a programming language used for web development.
HTML stands for HyperText Markup Language.
CSS is used for styling web pages.
API stands for Application Programming Interface.`,
        
        creative: `if input is tell me a story then respond Once upon a time, in a digital realm, there was an AI who loved to learn...
if input is creative idea then respond How about a device that translates pet thoughts into human language?
if input is poem then respond Roses are red, Violets are blue, I'm an AI, Learning from you.`
      };
      
      document.getElementById('trainText').value = presets[preset] || presets.basic;
      toggleQuickTraining();
      MMI.showNotification(`Loaded ${preset} training preset`);
    }

    function clearChat() {
      if (confirm('Are you sure you want to clear the chat history?')) {
        document.getElementById('log').innerHTML = '';
        MMI.showNotification('Chat history cleared');
      }
    }

    async function resetSystem() {
      if (confirm('Are you sure you want to reset the entire system? This will delete all data and cannot be undone.')) {
        try {
          indexedDB.deleteDatabase(MMI.dbName);
          MMI.showNotification('System reset. Refreshing page...');
          setTimeout(() => {
            location.reload();
          }, 2000);
        } catch (error) {
          console.error('Reset error:', error);
          MMI.showNotification('Reset failed', 'error');
        }
      }
    }

    // Initialize the system when the page loads
    document.addEventListener('DOMContentLoaded', async () => {
      const statusText = document.getElementById('statusText');
      statusText.textContent = 'Initializing MMI System...';
      
      try {
        await MMI.initDB();
        await MMI.loadAllData();
        updateDashboard();
        
        statusText.textContent = 'System Ready';
        MMI.showNotification('MMI System initialized successfully');
        
        // Set up event listeners
        const userInput = document.getElementById('userInput');
        const trainText = document.getElementById('trainText');
        
        userInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            sendMessage();
          }
        });
        
        trainText.addEventListener('keydown', e => {
          if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
            trainMMI();
          }
        });
        
        // Make functions globally available
        window.sendMessage = sendMessage;
        window.trainMMI = trainMMI;
        window.trainMMIAdvanced = trainMMIAdvanced;
        window.switchTab = switchTab;
        window.autoCategorize = autoCategorize;
        window.clearTrainingText = clearTrainingText;
        window.loadExample = loadExample;
        window.showExamples = showExamples;
        window.clearCategory = clearCategory;
        window.exportCategory = exportCategory;
        window.searchMemory = searchMemory;
        window.updateConfidence = updateConfidence;
        window.updateContextSize = updateContextSize;
        window.updateLearningRate = updateLearningRate;
        window.updateCreativity = updateCreativity;
        window.updatePersonality = updatePersonality;
        window.updateResponseStyle = updateResponseStyle;
        window.updateResponseLength = updateResponseLength;
        window.saveConfiguration = saveConfiguration;
        window.resetConfiguration = resetConfiguration;
        window.refreshStats = refreshStats;
        window.optimizeDatabase = optimizeDatabase;
        window.runDiagnostics = runDiagnostics;
        window.backupData = backupData;
        window.quickBackup = quickBackup;
        window.restoreData = restoreData;
        window.importFromURL = importFromURL;
        window.importTrainingData = importTrainingData;
        window.exportTrainingData = exportTrainingData;
        window.exportConversations = exportConversations;
        window.exportConfiguration = exportConfiguration;
        window.toggleQuickTraining = toggleQuickTraining;
        window.loadPreset = loadPreset;
        window.clearChat = clearChat;
        window.resetSystem = resetSystem;
        
      } catch (error) {
        console.error('Initialization error:', error);
        statusText.textContent = 'System Error - Check Console';
        MMI.showNotification('Failed to initialize MMI System', 'error');
      }
    });
  </script>
</body>
</html>
